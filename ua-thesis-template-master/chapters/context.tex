\chapter{Context}
\label{chapter:context}

The present chapter provides a comprehensive understanding of the technical underpinnings of 
\ac{sgx} and the protection of sensitive data.
It begins with the introduction of the concept of sensitive data, followed by \ac{tee}s, giving an overview of this type of mechanism. 
Then the chapter compares technologies, analyzing the distinctions between several \ac{tee}s implementations. 
After this, the discussion focuses on Intel \ac{sgx}, detailing its architecture, workflow, and security mechanisms, 
concluding with an analysis of the technical challenges associated with data processing within an enclave.

\section{Sensitive Data}

Driven by technological advances and institutional needs, nearly all buildings are now equipped with internet access provided through 
\ac{ap}. These allow for the determination of user location with a reasonable degree of precision, 
as users must connect to a specific \ac{ap} to access the network.

Although often categorized as technical metadata, it presents privacy challenges when through the lens of sensitive data. 
While raw location logs may not possess intrinsic sensitiveness, like a direct medical diagnosis might, it is possible to 
acquire sensitive information through their processing context. 
As \citet{04_article} argue, the critical factor is the computational distance required to infer sensitive 
information from apparently neutral data.

In the case of indoor positioning, this computational distance is low, the aggregation of location traces creates a high 
risk of linkability, where disparate datasets, such as anonymous WiFi logs and public class schedules, can be easily cross referenced. 
This reduces the effort necessary to de-anonymize users, transforming technical data into identifiable information.

The following list exemplifies sensitive information used for indoor location mentioned throughout this document:

\begin{itemize}
    \item \textbf{\ac{mac} Address:} A persistent hardware identifier assigned to the network interface controller, 
    this serves as a static fingerprint that uniquely identifies a user's device across different sessions and locations.
    \item \textbf{\ac{uu}:} The unique user identifier (such as a student ID, employee username, or email) 
    required for network authentication.
    \item \textbf{Connection Logs:} Time records containing precise association and disassociation timestamps,
    these allow for the reconstruction of a user's daily routine, duration of stay, and punctuality patterns.
    \item \textbf{Spatial Hierarchy:} Topological data classifying location from macro to micro levels, like the location of the \ac{ap} the user connected to.
    \item \textbf{Visual and Biometric Data:} In systems utilizing optical sensors, raw data includes high-resolution images 
    or video capable of revealing biometric features and behavioral signatures.
\end{itemize}

\section{Trusted Execution Environments (TEEs)}
% Definir Trusted Computing e talvez exemplo
Before defining \ac{tee}s, it is essential to understand the underlying concept of \ac{tc}, as defined by 
\citet{01_7345265}, a \ac{tc} aims to enable systems to achieve secure computation, privacy, and data protection. 
Historically, \ac{tc} relied on a dedicated hardware component to provide a functional interface for security operations, 
one common example is the \ac{tpm}, which allows a system to prove its integrity and securely store cryptographic keys,  
however, a limitation of the \ac{tpm} is its inability to perform isolated execution of arbitrary code, 
since it is mainly designed for passive storage and reporting, rather than active processing.
But more recent approaches to \ac{tc}, shift the execution of arbitrary code to a trusted environment that allows tamper resistant 
execution of its applications.

%Definição de TEE (isolamento de código e dados).
%Propriedades principais: Confidencialidade e Integridade.
While various terminologies exist in the literature, this dissertation adopts the term \ac{tee}, this is defined by \citet{01_7345265} 
as a secure, integrity protected computational environment, typically with isolated memory and specific storage capabilities. 
Its primary objectives are to guarantee the authenticity of the executed code, the integrity of the runtime state and the confidentiality of the data, 
like \ac{cpu} registers, while protecting code, memory, and sensitive \ac{io} from unauthorized access, in addition 
a \ac{tee} should have the ability to support remote attestation, allowing third parties to verify the trustworthiness of the environment, 
although specific implementation details may vary across different types of \ac{tee}s. 

% Distinguir entre hardware e software
The implementation of these can differ, leading to a categorization of \ac{tee}s based on their enforcement mechanism, 
hardware-based \ac{tee}s rely on specific hardware extensions, such as Intel \ac{sgx}, to enforce isolation at the lower level, 
effectively anchoring trust in the physical processor, in contrast, software-based \ac{tee}s depend on a software layer 
typically a hypervisor or microkernel to protect the execution environment. 
\citet{01_7345265} proposed some definitions represented in the following figure.
\begin{figure}
  \includegraphics[width=\linewidth]{figs/TEE_Building_Blocks.png}
  \caption{Overview of \ac{tee} building blocks, image by \citet{01_7345265}.}
  \label{fig:TEE_Building_Blocks}
\end{figure}
\newpage
As seen in the previous picture, a TEE in composed by building blocks such as:
\begin{itemize}
    \item{\normalsize Secure Boot: guarantees that only code of a certain property can be loaded during boot.}
    \item{\normalsize Secure Scheduling: provides a balanced coordination between the \ac{tee} and the rest of the system.}
    \item{\normalsize Inter-Environment Communication: Interface that allows the \ac{tee} to communicate with the rest of the system.}
    \item{\normalsize Secure Storage: Storage where confidentiality, integrity and authorized access of stored data is guaranteed.}
    \item{\normalsize Trusted I/O Path: Communication between \ac{io} peripherals with authenticity and sometimes confidentiality.}
\end{itemize}

% Diferença entre o ambiente não confiavel e o TEE.
In contrast to the isolation of the \ac{tee}, the remaining portion of the system is often referred to as the \ac{ree} or the untrusted environment, 
this includes the traditional operating system, the hypervisor, and the standard application stack (yellow component of the Figure\ref{fig:ree_vs_tee}). 
While the \ac{ree} is optimized for performance, versatility, and accessing peripherals, it looses the security guarantees 
required for sensitive data processing, as it makes it vulnerable software attacks. 
The architectural principle of trusted computing is the strict separation between these two worlds, 
the \ac{tee} protects its assets even when the surrounding \ac{ree} is fully compromised.
This separation can be observed in the Figure \ref{fig:ree_vs_tee}.
\begin{figure}
  \begin{center}
  \includegraphics[scale=0.7]{figs/ree_vs_tee.png}
  \caption{Overview of \ac{ree} and of \ac{tee}, image by \citet{02_phdthesis}.}
  \label{fig:ree_vs_tee}
  \end{center}
\end{figure}

\section{TEE Technologies}
Several \ac{tee} implementations exist, such as ARM TrustZone, AMD \ac{sev}, and Intel's most recent \ac{tdx}, 
this chapter provides a comparative overview of these technologies, however, Intel \ac{sgx}, the focus of this dissertation, 
is reviewed in greater detail in the subsequent chapter.

\subsection{ARM TrustZone}

% All this text was based on Demystifying Arm TrustZone: A Comprehensive Survey
Initially introduced in 2004, ARM TrustZone is a set of hardware security extensions available on ARM processors, while first 
implemented on the Cortex-A series, it was later adapted for the more recent Cortex-M series, with some architectural differences 
suited for microcontrollers. 
Contrary to a standalone component, TrustZone is an approach designed to be integrated into a \ac{soc}, 
securing not just the processor but the entire electronic device, as described by \citet{05_arm_trustzone}, in this model
the architecture is centered around the concept of distinct domains, the Secure World, the trusted environment, and 
the Normal World, the untrusted environment, as seen in Figure \ref{fig:arm_trustzone}.

\begin{figure}
  \begin{center}
  \includegraphics[scale=0.9]{figs/TrustZone_architecture.png}
  \caption{ARM TrustZone technology, image by \citet{05_arm_trustzone}.}
  \label{fig:arm_trustzone}
  \end{center}
\end{figure}

\newpage

This isolation allows software to execute with different privilege levels, preventing untrusted applications 
in the Normal World from directly accessing resources allocated to the Secure World. 
The state of the processor is determined by the \ac{ns} bit, typically located in the \ac{scr}, which effectively partitions the system's hardware resources.

To manage the transition between worlds, TrustZone employs a monitor mode, which executes in a secure state 
independent of the \ac{ns} bit, this mode bridges the two software stacks and is entered via the privileged \ac{smc} instruction or through specifically 
configured hardware exceptions. 

Hardware isolation is reinforced by banked registers, which guarantees that security critical system registers are 
either hidden from the untrusted environment or are strictly accessed from the trusted environment.
Regarding memory infrastructure, TrustZone introduces components such as the \ac{tzasc} for \ac{dram} and the \ac{tzma} for 
off-chip \ac{rom}/\ac{sram}, these controllers partition memory into trusted and untrusted regions, preventing the Normal World from accessing secure 
memory while allowing the Secure World full access. 
TrustZone \ac{mmu} maintains separate virtual to physical translation tables for each domain, and cache isolation is 
enforced via an additional tag bit on cache lines. 
Finally, the \ac{tzpc} extends this isolation to system peripherals, restricting access to specific devices based 
on the security domain.

In recent years, academic and industrial interest in this technology has surged, driven by the availability of 
technical documentation and accessible development platforms from manufacturers like Xilinx, this transparency has facilitated 
adoption within the community, particularly in the context of \ac{rd}.

While TrustZone provides a robust \ac{tee} for the mobile and embedded ecosystem, its reliance on ARM architecture makes it 
less suitable for the available infrastructure, where x86 architectures are more common.

\subsection{AMD SEV}

Introduced in 2016, \ac{sev} is stated to be the first x86 technology that was design to isolate \ac{vm}s from the hypervisor, since 
historically these have been considered trusted components, this allows for example, clients in the cloud to secure their \ac{vm} 
workload from the cloud administrator, keeping their data confidential and minimizing exposure.
AMD did this using main memory encryption in \ac{sev}, with this, individuals \ac{vm}s were assigned an individual key to encrypt all data, 
preventing the hypervisor from reading clear text information, as cited by \citet{05_amd_sev}.
Later in 2017, a new version came out, the AMD \ac{sev-es} that added the additional feature of \ac{cpu} register state protection, in order to 
do this, in \ac{sev-es} the \ac{vm} register state is encrypted at each hypervisor transition, preventing the hypervisor from seeing 
the data that is being used, adding confidentiality to in-memory data.

The most recent version is the \ac{sev-snp}, built on top of the previous versions while adds hardware based protections like 
memory integrity protection to prevent attacks like data replay, memory re-mapping, it also implements 
protection in interrup behavior. 

This is, in the reviewed literature, according to \citet{06_amdsev_inteltdx}, the first \ac{cvm}, 
which are \ac{vm}s designed to alleviate the programmability and usability challenges of the previously proposed 
trusted computing technologies, by providing abstraction at the level of the \ac{vm}.
This technology uses a dedicated processor, the \ac{asp} to manage the security features, this is an ARM-based processor that 
is separated from the main 32-bit core, but directly integrated in the \ac{cpu}, which also allows for remote attestation.

\begin{figure}
  \begin{center}
  \includegraphics[scale=1]{figs/amd_sev_snp_architecture.png}
  \caption{AMD \ac{sev} Architecture, image by \citet{06_amdsev_inteltdx}.}
  \label{fig:amd_sev}
  \end{center}
\end{figure}

\newpage

The Figure \ref{fig:amd_sev} shows the overview of the AMD \ac{sev-snp}, where green zones ilustrate \ac{cvm}s with unmodified software (orange) 
and with modified software (purple) and the blue areas are trusted components, the vertical black line indicates that 
each \ac{cvm} is isolated from the host and other encrypted \ac{vm}s. This \ac{vm} executes in an isolated 
environment where its memory and state registers are encrypted via a unique key managed by the \ac{asp}, 
this safeguards the integrity of guest address translations and strictly isolates the 
execution by blocking \ac{smi} events and preventing access from the \ac{smm}. 
This architecture also introduces \ac{vmpl}, a four-tiered privilege hierarchy to traditional x86 rings  
that enables a \ac{svsm} running at the highest level 
\ac{vmpl}0 to securely offer services like virtual \ac{tpm} and live migration.

\subsection{Intel TDX}

With the same goals as AMD \ac{sev}, Intel \ac{tdx} is an extension introduced with the 4th Generation Intel Xeon Scalable processors to 
enable confidential computing. 
This technology facilitates the deployment of \ac{vm}s, referred to as \ac{td}s, under the supervision of the \ac{seam}, this provides encrypted \ac{cpu} 
state and memory, with integrity protection and remote attestation, addressing scenarios where the cloud host platform is considered 
untrustworthy within the threat model
\footnote{A threat model is a structured approach to identifying potential security risks, defining attacks from the perspective of 
an adversary to strengthen system defenses \citep{threat_model}.}. 

Technically, \ac{tdx} builds upon other Intel technologies such as \ac{vt} and \ac{mktme}, together, these components enforce 
the confidentiality and integrity of \ac{td} memory and \ac{cpu} states, ensuring that they can neither be accessed nor tampered with by other 
entities in the environment, such as the hypervisor or neighboring \ac{vm}s in the same cloud tenant. Although it also uses \ac{dcap} and \ac{sgx} 
for remote attestation. 

According to \citet{12_intel_tdx} it achieves the previous using a combination of three components, namely, memory access control, runtime memory encryption and an 
Intel-signed \ac{tdx} module that does the handling of security-sensitive \ac{td} management operations. 

\newpage
\begin{figure}
  \begin{center}
  \includegraphics[scale=0.5]{figs/intel_tdx_architecture.png}
  \caption{Intel \ac{tdx} Architecture, image by \citet{12_intel_tdx}.}
  \label{fig:intel_tdx}
  \end{center}
\end{figure}

The Figure \ref{fig:intel_tdx} illustrates the runtime architecture of the \ac{tdx} technology. The two main components are the \ac{tdx} compatible processors, that provide 
functional capabilities like hardware-assisted virtualization, memory encryption, integrity protection, and the \ac{tdx} Module, that facilitates the manipulation of 
\ac{td} while applying security guarantees, besides this, the module provides two interface functions, a host-side interface and a guest-side interface. 
The previous module is loaded in to the \ac{seam} range, a portion of memory that is reserved during boot. Another component present in this range 
is the \ac{seam} loader, which is responsible for installing and updating the module. 
\ac{seam} provides two execution modes, the \ac{seam} \ac{vmx} root mode and non-root mode, a \ac{tdx} compatible hypervisor operates in the \ac{vmx} root mode 
and uses the SEAMCALL introduction to call host-side functions, functions that start with TDH, of the modulea. 

This is possible since the the logical processor changes \ac{vmx} root mode into \ac{seam} \ac{vmx} root mode and starts executing code within the TDX Module, 
upon completing it returns in \ac{vmx} root mode with the instruction SEAMRET. 
The \ac{td}s run in \ac{seam} \ac{vmx} non-root mode, since \ac{tdx} supports the execution of unmodified user-level applications within a \ac{td}, like a normal 
\ac{vm}, but the guest \ac{os} kernel (TDX-enlightened OS in Figure \ref{fig:intel_tdx}), needs to be altered in order to align with the \ac{tdx} plataform, namely 
managing \ac{tdx} exceptions via an internal handler, implementation of a mechanism for communication between the \ac{td} and the \ac{tdx} module, 
transitioning memory pages from private to shared \ac{io} operations, although implementation details may vary according to the \ac{os} in use.

Unlike \ac{sev} and \ac{tdx}, which aim to secure entire \ac{vm}, \ac{sgx} focuses on application isolation, and  
for the specific purpose of this dissertation, a lightweight application to process logs, \ac{sgx} is more suited.

\section{Intel Software Guard Extensions (SGX)}

In similarity with previous \ac{tee} implementations, \ac{sgx} is a set of extensions for the Intel architecture with the goal to allow 
for integrity and confidentiality during computation in a computer where all privileged components might be compromised, as defined by \citet{sgx}.

This emerged as a solution to a recurring problem known as secure remote computation, which refers to the difficulty of executing software on a remote computer owned and maintained by 
an untrusted party. 
In this context, \ac{sgx} is one of many attempts to address this challenge by leveraging trusted hardware. 
To achieve this, the hardware establishes a secure container and a service that enables secure computation for the user.

In simpler terms, this model relies on software attestation, a capability that allows the hardware to prove to a remote user that they are 
communicating with the intended application on non-compromised hardware and that the code has not been altered.

This is achieved through a cryptographic signature that certifies the hash of the enclave's content, the user verifies this signature against a root of trust in 
the manufacturer's hardware, confirming the validity of the attestation key.

\subsection{Enclave}
% Explicar o conceito de Enclaves.
An important concept in \ac{sgx} terminology is an enclave, as described by \citet{12_intel_tdx}, is a protected region within an application's 
address space that allows the isolation of sensitive code and data from the rest of the system. 

% Enclave Control Structure 
To maintain the security properties and persistent identity of each enclave instance, \ac{sgx} employs a control structure known as the \ac{secs}. 
This structure contains the stored metadata for each individual enclave and is kept in a dedicated \ac{epc} page with the type \texttt{PT\_SECS}. 
During the enclave's lifecycle, the \ac{secs} is the first page allocated and the last to be deallocated, serving as the persistent identifier, consequently, the system software utilizes the 
virtual address of the \ac{secs} to reference the specific enclave when issuing \ac{sgx} instructions. 
Despite being mapped for identification purposes, the \ac{secs} page remains inaccessible to the trusted enclave code and the untrusted system software, due to 
the present of sensitive information regarding the enclave.

% Enclave Memory Layout
With the enclave's identity and attributes anchored in the \ac{secs}, its execution context is defined by a window in the virtual address space, known as the \ac{elrange}. 
This range is used to map all code and sensitive data to the corresponding \ac{epc} pages and any memory access attempted by the enclave outside this defined area is automatically 
mapped to access non-\ac{epc} memory via the same virtual addresses, allowing for interaction with the rest of the application.

%Mencionar atributos
While the \ac{elrange} defines the memory boundaries of the enclave, the nature of its execution environment is defined by the ATTRIBUTES field within the \ac{secs}, 
via flags such as \texttt{DEBUG}, \ac{xfrm}, and \texttt{MODE64BIT}. 
The \texttt{DEBUG} is intended to be used during development, since when set, it enables debugging features that allow the reading and modification 
of the enclave's memory. 
The \ac{xfrm} enforces the enclave code to run with the architectural extensions enabled by the compiler, done by defining the value for the \texttt{XCR0} register during execution. 
Finally, the \texttt{MODE64BIT} flag determines whether the enclave operates using the 64-bit architecture, likely for backward compatibility.

%Mencionar o ciclo de vida
Once these operational parameters are defined in the metadata, the enclave must pass through a specific sequence of states to become executable. 
% Consequently, the enclave lifecycle is related with resource management, specifically the allocation of \ac{epc} pages. 
This process begins with creation, where the \texttt{ECREATE} instruction transforms a free \ac{epc} page into the enclave's \ac{secs}, initializing it with architectural parameters and setting the 
INIT attribute to false, while in this state, the lifecycle enters the loading phase, where the system software uses \texttt{EADD} to allocate pages for code and data, 
while \texttt{EEXTEND} updates the enclave's cryptographic measurement. 
After loading, initialization is started by the \texttt{EINIT} instruction, that validates a token and sets the \texttt{INIT} attribute to true, 
sealing the enclave from modification and enabling execution in Ring 3. 
Finally, the destruction of the enclave occurs with the EREMOVE instruction, which deallocates pages by clearing their \texttt{VALID} bit, ensuring that the \ac{secs} page is only destroyed once all other 
pages associated with the enclave have been successfully removed, as shown in Figure \ref{fig:sgx_enclave_lifecycle}.

\newpage
\begin{figure}
  \begin{center}
  \includegraphics[scale=0.6]{figs/sgx_enclave_lifecycle.png}
  \caption{An Enclave Lifecycle, by \citet{sgx}.}
  \label{fig:sgx_enclave_lifecycle}
  \end{center}
\end{figure}

\subsection{Architecture and Workflow}

To secure its memory from the untrusted environment, \ac{sgx} reserves a region in \ac{dram} known as the \ac{prm}. 
This region is isolated by the \ac{cpu}, blocking all non-enclave memory accesses from softwares such as the kernel or hypervisor, 
as well as protecting against \ac{smm} and \ac{dma} attacks from peripherals.

The \ac{prm} also contains the \ac{epc}, which consists of 4KB memory pages that store the enclave's code and data. 
While the allocation of these \ac{epc} pages is managed by the untrusted system software, the security is enforced by hardware. 
The \ac{cpu} tracks the state and permissions of every \ac{epc} page in the \ac{epcm} to guarantee that each page belongs to a specific 
enclave and cannot be mapped by unauthorized entities.

The workflow begins with the loading of code and data into the enclave, during this operation the untrusted system software asks the \ac{cpu} to 
copy data from unprotected memory into the \ac{epc} pages and assigns them to the enclave. 
After the loading is completed, the system software indicates to the \ac{cpu} to mark the enclave as initialized. 
At this point the loaded code becomes executable in the enclave and the loading method is disabled to prevent modifications. 
% Throughout this process, the \ac{cpu} computes a cryptographic hash of the enclave's content, which becomes the enclave's measurement hash.
% This allows a remote party to execute a software attestation process, to prove the communication is done with an enclave with a specific measurement hash, 
% and is running in a safe environment.

The execution flow of an enclave is governed by specific \ac{cpu} instructions, these are similar to context switching between user mode and kernel mode, 
but the enclave execution remains within Ring 3.

\newpage

\subsection{Enclave Page Cache}
% Explicar a divisão da memória (EPC - Enclave Page Cache).
As mentioned previously, the content of the enclave and necessary data are data structures in the \ac{epc} as shown in the Figure \ref{fig:sgx_epc}.

\begin{figure}
  \begin{center}
  \includegraphics[scale=0.8]{figs/sgx_epc_overview.png}
  \caption{\ac{epc} Memory overview, by \citet{sgx}.}
  \label{fig:sgx_epc}
  \end{center}
\end{figure}

The \ac{sgx} design allows for multiple enclaves running at the same time, which translates to the necessity of a multi-process environment. This is possible due to the capability of the \ac{epc} 
to assign different pages to different enclaves.
Non-trusted software cannot directly access it, since it is contained in the \ac{prm}.

This mechanism is managed by the same system software that manages the rest of the computer's physical memory, which could be a hypervisor or the \ac{os} kernel. Both accomplish this with the use 
of \ac{sgx} introductions to allocate and free pages in the enclaves. But as mentioned previously, this is not a trusted component, so the \ac{sgx} processor verifies every allocation decision, 
and has the possibility to refuse them if they compromise any security guarantee.

To perform these verifications, \ac{sgx} keeps some information about previous allocation decisions for each \ac{epc} page in the \ac{epcm}, an array with one entry per page. 
Three relevant fields in each entry that affect the ownership of the \ac{epc} page are \texttt{VALID}, a bit indicating whether an EPC page is currently active and allocated to an enclave, if 
set to one it signifies the page is in use, preventing reallocation or overwriting by other instructions, \texttt{PT}, eight bits that define the type of page and \texttt{ENCLAVESECS} which identifies the 
enclave that owns the page.

The contents of this map can only be read by the \ac{sgx} as stated in Intel \ac{sdm}.

\subsection{ECalls and OCalls}
%Mecanismo de ECalls e OCalls (entrar e sair do enclave e comunicação com o mundo "inseguro").
In Intel SGX, \texttt{ECALL} and \texttt{OCALL} are mechanisms for communication between the untrusted application and the trusted enclave. 

\texttt{ECALL}s allow the untrusted application to invoke a pre-defined function inside the enclave, passing input parameters and pointers to shared memory within the application.

On the other hand, \texttt{OCALLs} enable the enclave to invoke a pre-defined function in the untrusted application, but unlike \texttt{ECALL}s, 
cannot share enclave memory directly and must copy parameters into the application's memory before the call.

Both \texttt{ECALL}s and \texttt{OCALL}s are defined using the \ac{edl}, where \texttt{ECALL}s are declared in the trusted section and OCALLs in the untrusted section of the file.
During the build process, the Edger8r
\footnote{Tool provided by the Intel SGX \ac{sdk} that automatically generates the code that connects the untrusted application and the trusted enclave}
tool parses the \ac{edl} file and generates function wrappers around the actual functions.

\subsection{Attestation, Sealing and Unsealing}
SGX relies on software attestation to prove to a remote party that it is communicating with a specific piece of software running in a secure container hosted by trusted hardware. 
One of the most important components to this process is the enclave's identity, which is cryptographically established during 
its initialization and loading phases, as mentioned previously.

The identity of an enclave is primarily defined by two measurement registers located in the enclave's \ac{secs}. 
The first, \texttt{MRENCLAVE}, contains a SHA-256 hash that uniquely identifies the enclave's code and data contents, acting as a cryptographic log of the creation process, 
it incorporates every instruction used to build the enclave, consequently, any modification to the loaded code, data, or their order results in a completely 
different \texttt{MRENCLAVE} value, ensuring that the running software corresponds exactly to the developer's intent. 
Complementing this is \texttt{MRSIGNER}, which identifies the entity that signed the enclave rather than the code itself. 
This register stores the SHA-256 hash of the public RSA key modulus used to sign the \texttt{SIGSTRUCT} certificate, allowing remote parties to trust an 
enclave based on the author's reputation. 

\newpage
\begin{figure}
  \begin{center}
  \includegraphics[scale=0.8]{figs/enclave_identity.png}
  \caption{Establishing an Enclave’s Identity, by \citet{sgx}.}
  \label{fig:enclave_identity}
  \end{center}
\end{figure}

The attestation process leverages these identities through a mechanism known as local attestation, where an enclave proves its identity to another enclave on the same platform using the 
\texttt{EREPORT} instruction. 
To extend this trust remotely, \ac{sgx} uses a privileged enclave known as the Quoting Enclave, that receives the local report, verifies it, and replaces the local MAC with a 
cryptographic signature produced by the processor's unique attestation key. 
This signature, which includes the \texttt{MRENCLAVE} and \texttt{MRSIGNER}, serves as the final proof to the remote service provider that the enclave is authentic and running on genuine hardware.

The initialization process is finalized by the \texttt{EINIT} instruction, which validates the enclave's \texttt{SIGSTRUCT}, this checks that the measurement in the certificate 
matches the calculated \texttt{MRENCLAVE} and populates the \texttt{MRSIGNER} field in the \ac{secs}, defining the enclave's identity before it can begin execution.

\section{Memory and Performance Limitations in SGX}
Even though \ac{sgx} provides confidentiality and integrity, it introduces performance overheads and resource constraints.
These limitations are derived from the restricted size of the secure memory region and the high cost of transitioning between trusted and 
untrusted execution modes.

One constraint is the limited capacity of the \ac{epc}, since it resides within the \ac{prm}, where the memory is limited.
When an application's working set exceeds the available \ac{epc} capacity, the system must perform paging
operations to evict \ac{epc} pages to unprotected \ac{dram}. 
Unlike normal paging, \ac{sgx} paging requires cryptographic operations, where the hardware encrypts the page before writing it to untrusted memory, and verify and decrypt it upon restoration. 
This causes a performance overhead, often referred to as the \ac{epc} Bottleneck, making large-memory workloads impractical without optimization. 
Various approaches appear in related work, such as data partitioning and demand paging optimization, attempt to mitigate this by minimizing the frequency of page swaps.

In addition to memory capacity, the cost of entering (\texttt{ECALL}) and exiting (\texttt{OCALL}) an enclave is evident, since a 
domain transition involves hardware operations, including flushes, security checks, and context saving, which are necessary to prevent information leakage. 

